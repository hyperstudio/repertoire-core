CODE IN DEVELOPMENT!  DO NOT USE WITHOUT PERMISSION.


NOTES for deployment documentation.

- on production server: 
  * main database is hyperstudio
  * access to various schemas is controlled by user logging in
  * login name should be same as project name (e.g. website)
  * schemas should be same as project appreviation


NOTES for project development.

--- DATABASE PRIMING.
- create a new postgresql user and schema for project.  in this example, we'll create a schema for berliner sehen, which uses
- the repertoire core schemas.
CREATE USER ber;
ALTER USER cfrp ENCRYPTED PASSWORD 'cfrp_password';             -- change password accordingly; note it will be included in application
CREATE SCHEMA ber AUTHORIZATION ber;
GRANT USAGE ON SCHEMA core TO ber;
ALTER USER ber SET search_path TO ber,core,public,pg_catalog;


NOTES for repertoire core documentation.

- rake repertoire_core:migrate task does User.auto_migrate!
  * intended for initial install of framework
- hostname should be set with merb -hfoohost
  * port not available
- because roles are hierarchical, anyone with grant_foo s.t. foo > bar can grant bar
	* however, only direct grant_foo members are emailed to review on subscription requests
- to add your own project-specific roles:
  * put the create / replace code in lib/tasks/foo.rake, e.g. in berlinersehen:install rake task
  * make all your roles use a project specific prefix (e.g. 'ber')


NOTES for module development.

- follow the directions on database priming above.
- styling guide for code documentation (YARD)
- code submission should update YARD documentation
- to do live tests of assets like stylesheets and javascript, put a soft link in the shell application's public/slice
  directory, to public/* in the module code
- use a containing namespace div for all module css:
      <body id="repertoire_core">...   /* use the module name as the namespace */
    and make all enclosed css dependent on it:
      #repertoire_core .banner
  this will mean fewer css clashes between modules


NOTES for css development.

- styling guide practices for web code [ i.e. camelcase or underlines for CSS ]




Instructions for installation:

file: config/init.rb

# add the slice as a regular dependency

dependency 'repertoire_core'

# if needed, configure which slices to load and in which order

Merb::Plugins.config[:merb_slices] = { :queue => ["RepertoireCore", ...] }

# optionally configure the plugins in a before_app_loads callback

Merb::BootLoader.before_app_loads do
  
  Merb::Slices::config[:repertoire_core][:option] = value
  
end

file: config/router.rb

# example: /repertoire_core/:controller/:action/:id

r.add_slice(:RepertoireCore)

# example: /foo/:controller/:action/:id

r.add_slice(:RepertoireCore, 'foo') # same as :path => 'foo'

# example: /:lang/:controller/:action/:id (with :a param set)

r.add_slice(:RepertoireCore, :path => ':lang', :params => { :a => 'b' })

# example: /:controller/:action/:id

r.slice(:RepertoireCore)

Normally you should also run the following rake task:

rake slices:repertoire_core:install

------------------------------------------------------------------------------

You can put your application-level overrides in:

host-app/slices/repertoire_core/app - controllers, models, views ...

Templates are located in this order:

1. host-app/slices/repertoire_core/app/views/*
2. gems/repertoire_core/app/views/*
3. host-app/app/views/*

You can use the host application's layout by configuring the
repertoire_core slice in a before_app_loads block:

Merb::Slices.config[:repertoire_core] = { :layout => :application }

By default :repertoire_core is used. If you need to override
stylesheets or javascripts, just specify your own files in your layout
instead/in addition to the ones supplied (if any) in 
host-app/public/slices/repertoire_core.

In any case don't edit those files directly as they may be clobbered any time
rake repertoire_core:install is run.

------------------------------------------------------------------------------

About Slices
============

Merb-Slices is a Merb plugin for using and creating application 'slices' which
help you modularize your application. Usually these are reuseable extractions
from your main app. In effect, a Slice is just like a regular Merb MVC
application, both in functionality as well as in structure.

When you generate a Slice stub structure, a module is setup to serve as a
namespace for your controller, models, helpers etc. This ensures maximum
encapsulation. You could say a Slice is a mixture between a Merb plugin (a
Gem) and a Merb application, reaping the benefits of both.

A host application can 'mount' a Slice inside the router, which means you have
full over control how it integrates. By default a Slice's routes are prefixed
by its name (a router :namespace), but you can easily provide your own prefix
or leave it out, mounting it at the root of your url-schema. You can even
mount a Slice multiple times and give extra parameters to customize an
instance's behaviour.

A Slice's Application controller uses controller_for_slice to setup slice
specific behaviour, which mainly affects cascaded view handling. Additionaly,
this method is available to any kind of controller, so it can be used for
Merb Mailer too for example.

There are many ways which let you customize a Slice's functionality and
appearance without ever touching the Gem-level code itself. It's not only easy
to add template/layout overrides, you can also add/modify controllers, models
and other runtime code from within the host application.

To create your own Slice run this (somewhere outside of your merb app):

$ merb-gen slice <your-lowercase-slice-name>